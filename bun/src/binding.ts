
// This file is auto-generated by @chainsafe/bun-ffi-z. Do not edit.

import path from "node:path";
import { openLibrary } from "@chainsafe/bun-ffi-z";

const fns = {
  "validatePublicKey": {
    "args": [
      "ptr"
    ],
    "returns": "u32"
  },
  "publicKeyBytesValidate": {
    "args": [
      "ptr",
      "u64"
    ],
    "returns": "u32"
  },
  "publicKeyFromAggregate": {
    "args": [
      "ptr",
      "ptr"
    ],
    "returns": "void"
  },
  "compressPublicKey": {
    "args": [
      "ptr",
      "ptr"
    ],
    "returns": "void"
  },
  "serializePublicKey": {
    "args": [
      "ptr",
      "ptr"
    ],
    "returns": "void"
  },
  "uncompressPublicKey": {
    "args": [
      "ptr",
      "ptr",
      "u64"
    ],
    "returns": "u32"
  },
  "deserializePublicKey": {
    "args": [
      "ptr",
      "ptr",
      "u64"
    ],
    "returns": "u32"
  },
  "publicKeyFromBytes": {
    "args": [
      "ptr",
      "ptr",
      "u64"
    ],
    "returns": "u32"
  },
  "toPublicKeyBytes": {
    "args": [
      "ptr",
      "ptr"
    ],
    "returns": "void"
  },
  "isPublicKeyEqual": {
    "args": [
      "ptr",
      "ptr"
    ],
    "returns": "bool"
  },
  "aggregateFromPublicKey": {
    "args": [
      "ptr",
      "ptr"
    ],
    "returns": "void"
  },
  "aggregateToPublicKey": {
    "args": [
      "ptr",
      "ptr"
    ],
    "returns": "void"
  },
  "aggregatePublicKeys": {
    "args": [
      "ptr",
      "ptr",
      "u64",
      "bool"
    ],
    "returns": "u32"
  },
  "aggregateSerializedPublicKeys": {
    "args": [
      "ptr",
      "ptr",
      "u64",
      "u64",
      "bool"
    ],
    "returns": "u32"
  },
  "addAggregatePublicKey": {
    "args": [
      "ptr",
      "ptr"
    ],
    "returns": "void"
  },
  "addPublicKeyToAggregate": {
    "args": [
      "ptr",
      "ptr",
      "bool"
    ],
    "returns": "u32"
  },
  "isAggregatePublicKeyEqual": {
    "args": [
      "ptr",
      "ptr"
    ],
    "returns": "bool"
  },
  "validateSignature": {
    "args": [
      "ptr",
      "bool"
    ],
    "returns": "u32"
  },
  "sigValidate": {
    "args": [
      "ptr",
      "ptr",
      "u64",
      "bool"
    ],
    "returns": "u32"
  },
  "verifySignature": {
    "args": [
      "ptr",
      "bool",
      "ptr",
      "u64",
      "ptr",
      "bool"
    ],
    "returns": "u32"
  },
  "aggregateVerify": {
    "args": [
      "ptr",
      "bool",
      "ptr",
      "u64",
      "u64",
      "ptr",
      "u64",
      "bool"
    ],
    "returns": "u32"
  },
  "fastAggregateVerify": {
    "args": [
      "ptr",
      "bool",
      "ptr",
      "u64",
      "ptr",
      "u64"
    ],
    "returns": "u32"
  },
  "fastAggregateVerifyPreAggregated": {
    "args": [
      "ptr",
      "bool",
      "ptr",
      "u64",
      "ptr"
    ],
    "returns": "u32"
  },
  "verifyMultipleAggregateSignatures": {
    "args": [
      "ptr",
      "u64",
      "u64",
      "bool",
      "bool"
    ],
    "returns": "u32"
  },
  "signatureFromAggregate": {
    "args": [
      "ptr",
      "ptr"
    ],
    "returns": "void"
  },
  "compressSignature": {
    "args": [
      "ptr",
      "ptr"
    ],
    "returns": "void"
  },
  "serializeSignature": {
    "args": [
      "ptr",
      "ptr"
    ],
    "returns": "void"
  },
  "uncompressSignature": {
    "args": [
      "ptr",
      "ptr",
      "u64"
    ],
    "returns": "u32"
  },
  "deserializeSignature": {
    "args": [
      "ptr",
      "ptr",
      "u64"
    ],
    "returns": "u32"
  },
  "signatureFromBytes": {
    "args": [
      "ptr",
      "ptr",
      "u64"
    ],
    "returns": "u32"
  },
  "signatureToBytes": {
    "args": [
      "ptr",
      "ptr"
    ],
    "returns": "void"
  },
  "signatureSubgroupCheck": {
    "args": [
      "ptr"
    ],
    "returns": "bool"
  },
  "isSignatureEqual": {
    "args": [
      "ptr",
      "ptr"
    ],
    "returns": "bool"
  },
  "validateAggregateSignature": {
    "args": [
      "ptr"
    ],
    "returns": "u32"
  },
  "aggregateFromSignature": {
    "args": [
      "ptr",
      "ptr"
    ],
    "returns": "void"
  },
  "aggregateToSignature": {
    "args": [
      "ptr",
      "ptr"
    ],
    "returns": "void"
  },
  "aggregateSignatures": {
    "args": [
      "ptr",
      "ptr",
      "u64",
      "bool"
    ],
    "returns": "u32"
  },
  "aggregateSerializedSignatures": {
    "args": [
      "ptr",
      "ptr",
      "u64",
      "u64",
      "bool"
    ],
    "returns": "u32"
  },
  "addAggregate": {
    "args": [
      "ptr",
      "ptr"
    ],
    "returns": "void"
  },
  "addSignatureToAggregate": {
    "args": [
      "ptr",
      "ptr",
      "bool"
    ],
    "returns": "u32"
  },
  "subgroupCheckC": {
    "args": [
      "ptr"
    ],
    "returns": "bool"
  },
  "isAggregateSignatureEqual": {
    "args": [
      "ptr",
      "ptr"
    ],
    "returns": "bool"
  },
  "secretKeyGen": {
    "args": [
      "ptr",
      "ptr",
      "u64",
      "ptr",
      "u64"
    ],
    "returns": "u32"
  },
  "secretKeyGenV3": {
    "args": [
      "ptr",
      "ptr",
      "u64",
      "ptr",
      "u64"
    ],
    "returns": "u32"
  },
  "secretKeyGenV45": {
    "args": [
      "ptr",
      "ptr",
      "u64",
      "ptr",
      "u64",
      "ptr",
      "u64"
    ],
    "returns": "u32"
  },
  "secretKeyGenV5": {
    "args": [
      "ptr",
      "ptr",
      "u64",
      "ptr",
      "u64",
      "ptr",
      "u64"
    ],
    "returns": "u32"
  },
  "secretKeyDeriveMasterEip2333": {
    "args": [
      "ptr",
      "ptr",
      "u64"
    ],
    "returns": "u32"
  },
  "secretKeyDeriveChildEip2333": {
    "args": [
      "ptr",
      "ptr",
      "u32"
    ],
    "returns": "void"
  },
  "secretKeyToPublicKey": {
    "args": [
      "ptr",
      "ptr"
    ],
    "returns": "void"
  },
  "sign": {
    "args": [
      "ptr",
      "ptr",
      "ptr",
      "u64"
    ],
    "returns": "void"
  },
  "serializeSecretKey": {
    "args": [
      "ptr",
      "ptr"
    ],
    "returns": "void"
  },
  "deserializeSecretKey": {
    "args": [
      "ptr",
      "ptr",
      "u64"
    ],
    "returns": "u32"
  },
  "secretKeyToBytes": {
    "args": [
      "ptr",
      "ptr"
    ],
    "returns": "void"
  },
  "secretKeyFromBytes": {
    "args": [
      "ptr",
      "ptr",
      "u64"
    ],
    "returns": "u32"
  },
  "addPublicKeys": {
    "args": [
      "ptr",
      "ptr",
      "u64"
    ],
    "returns": "void"
  },
  "multPublicKeys": {
    "args": [
      "ptr",
      "ptr",
      "u64",
      "ptr",
      "u64",
      "ptr"
    ],
    "returns": "void"
  },
  "addSignatures": {
    "args": [
      "ptr",
      "ptr",
      "u64"
    ],
    "returns": "void"
  },
  "multSignatures": {
    "args": [
      "ptr",
      "ptr",
      "u64",
      "ptr",
      "u64",
      "ptr"
    ],
    "returns": "void"
  },
  "sizeOfPairing": {
    "args": [],
    "returns": "u32"
  },
  "aggregateWithRandomness": {
    "args": [
      "ptr",
      "u32",
      "ptr",
      "ptr"
    ],
    "returns": "u32"
  },
  "asyncAggregateWithRandomness": {
    "args": [
      "ptr",
      "u32",
      "ptr",
      "ptr",
      "callback"
    ],
    "returns": "u32"
  },
  "init": {
    "args": [],
    "returns": "u32"
  },
  "deinit": {
    "args": [],
    "returns": "void"
  }
} as const;
const lib = await openLibrary(path.join(import.meta.dirname, ".."), fns);

export const binding = lib.symbols;
export const close = lib.close;

